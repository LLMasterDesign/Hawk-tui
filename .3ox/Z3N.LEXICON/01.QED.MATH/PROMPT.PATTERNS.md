///â–™â––â–™â––â–â–â–™â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚â–‚///
â–›//â–â– âŸ¦âŠâŸ§ :: â§—-25.125 // Z3N.LEXICON :: PROMPT.PATTERNS â–â–

â–›///â– PROMPT.PATTERNS :: REUSABLE.TEMPLATES

Common prompt patterns and templates based on QED methodology.

â–›///â– STRUCTURE.PATTERNS

Theorem.Proof.Pattern
  ```
  Given: {initial conditions}
  Prove: {desired outcome}
  
  Proof:
  1. Step one with reasoning
  2. Step two with reasoning
  3. ...
  
  QED: {conclusion}
  ```

Pheno.Chain.Pattern
  ```
  Ï{Input}  â†’ {input description}
  Ï†{Process} â†’ {process steps}
  Ï„{Output}  â†’ {output description}
  ```

Rule.Application.Pattern
  ```
  Rule: {rule name}
  Condition: {when rule applies}
  Action: {what rule does}
  Priority: {rule priority}
  ```

â–›///â– COMMAND.PATTERNS

Status.Update
  â†’ User says "status update" â†’ provide summary
  â†’ Format: structured report
  â†’ Include: current state, progress, next steps

Project.Load
  â†’ /project {name} â†’ load project structure
  â†’ Load: meta.note, journal/, tasks/, plans/
  â†’ Open: !WORKDESK/{Project}.FORGE/

Journal.Create
  â†’ /sparkjournal â†’ create journal entry
  â†’ Get date: YYYY.MM.DD, Sirius time
  â†’ Create: Journal/Daily/YYYY.MM.DD.ProjectName.Journal.md

â–›///â– VALIDATION.PATTERNS

Input.Validation
  â†’ Check required parameters
  â†’ Verify format compliance
  â†’ Validate constraints

Output.Verification
  â†’ Verify output matches requirements
  â†’ Check for completeness
  â†’ Validate correctness

State.Consistency
  â†’ Ensure state transitions valid
  â†’ Check invariants maintained
  â†’ Verify no contradictions

â–›///â– ITERATION.PATTERNS

Refinement.Loop
  â†’ Generate initial result
  â†’ Check against requirements
  â†’ Refine if needed
  â†’ Repeat until satisfied

Error.Recovery
  â†’ Detect error condition
  â†’ Identify error type
  â†’ Apply recovery strategy
  â†’ Verify recovery successful

Progressive.Enhancement
  â†’ Start with minimal version
  â†’ Add features incrementally
  â†’ Verify each addition
  â†’ Maintain working state

â–›///â– COMPOSITION.PATTERNS

Pattern.Composition
  â†’ Combine multiple patterns
  â†’ Chain pattern applications
  â†’ Nest patterns hierarchically

Template.Inheritance
  â†’ Base template with common structure
  â†’ Specialized templates extend base
  â†’ Override specific sections

Modular.Prompts
  â†’ Break prompt into modules
  â†’ Compose modules as needed
  â†’ Reuse modules across contexts

â–›â–// RESPONDER â« â–¸
Prompt patterns provide reusable templates and structures that can be composed and 
adapted for different use cases, following QED principles for consistency and verifiability.
:: ğœµ

:: âˆ
